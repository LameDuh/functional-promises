{"version":3,"file":"cjs.min.js","sources":["../src/modules/errors.js","../src/modules/utils.js","../src/monads.js","../src/arrays.js","../src/events.js","../src/conditional.js","../src/promise.js","../src/index.js"],"sourcesContent":["const { inherits } = require('util');\n\ninherits(FunctionalError, Error)\n\ninherits(FunctionalUserError, FunctionalError)\ninherits(FPCollectionError, FunctionalError)\ninherits(FPUnexpectedError, FunctionalError)\ninherits(FPInputError, FunctionalError)\ninherits(FPTimeout, FunctionalError)\n\nexport function FunctionalError(msg, options) {\n  if (!(this instanceof FunctionalError)) return new FunctionalError(...arguments)\n  if (typeof msg === 'object') {\n    options = msg\n    if ( options.message ) msg = options.message\n  }\n  Error.call(this, msg)\n  if (typeof msg === 'string') this.message = msg\n  if (typeof options === 'object') {\n    Object.getOwnPropertyNames(options)\n      .forEach(key => {\n        this[key] = options[key]\n      })\n  }\n  this.name = this.constructor.name\n  // Capturing stack trace, excluding constructor call from it.\n  Error.captureStackTrace(this)\n}\n\nexport function FunctionalUserError() {\n  if (!(this instanceof FunctionalUserError)) return new FunctionalUserError(...arguments)\n  FunctionalError.call(this, ...arguments)\n}\n\nexport function FPUnexpectedError() {\n  if (!(this instanceof FPUnexpectedError)) return new FPUnexpectedError(...arguments)\n  FunctionalError.call(this, ...arguments)\n}\n\nexport function FPInputError() {\n  if (!(this instanceof FPInputError)) return new FPInputError(...arguments)\n  FunctionalError.call(this, ...arguments)\n}\n\nexport function FPCollectionError() {\n  if (!(this instanceof FPCollectionError)) return new FPCollectionError(...arguments)\n  FunctionalError.call(this, ...arguments)\n}\n\nexport function FPTimeout() {\n  if (!(this instanceof FPTimeout)) return new FPTimeout(...arguments)\n  FunctionalError.call(this, ...arguments)\n}\n\n\n","const utils = {\n  isPromiseLike(p) { return !!(p && typeof p.then === 'function') },\n  isFunction(fn) { return typeof fn === 'function' },\n  isEnumerable(list) { return list && Array.isArray(list) || list && typeof list[Symbol.iterator] === 'function' },\n  isObject(o) { return !!Object.prototype.toString.call(o) === '[object Object]' },\n\n  flatten(arr) {\n    if (!Array.isArray(arr)) throw new Error('Method `flatten` requires valid array parameter')\n    return arr.reduce((results, item) => results.concat(Array.isArray(item) ? utils.flatten(item) : [item]), [])\n  },\n}\nexport default utils","import { FPInputError } from './modules/errors'\n\nexport default function monads(FP) {\n\n  return {chain, chainEnd}\n\n  /**\n   * Start 'recording' a chain of commands, after steps defined call `.chainEnd()`\n   * @returns FunctionalPromise\n   */\n  function chain() {\n    // create a placeholder/initial promise to hold the steps/chain data\n    const promise = FP.resolve()\n    promise.steps = []\n    return promise\n  }\n\n  /**\n   * Call after starting a `.chain()`.\n   *\n   * One of the few non-chainable methods in the API.\n   * @returns a Function. It runs your functional chain!\n   */\n  function chainEnd() {\n    return input => {\n      if (!this.steps || this.steps.length <= 0) throw new FPInputError('No steps defined between .chain() & .chainEnd()')\n      let stepCount = 0\n      let {promise, resolve, reject} = FP.unpack()\n      while (stepCount < this.steps.length) {\n        const [fnName, , args] = this.steps[stepCount]\n        promise = promise[fnName](...args)\n        stepCount++\n      }\n      resolve(input)\n      return promise\n    }\n  }\n}\n","import utils from './modules/utils'\nimport { FPInputError, FPCollectionError, FunctionalError } from './modules/errors'\nconst { isEnumerable } = utils\n\nexport default function(FP) {\n\n  return { map, find, findIndex, filter, flatMap, reduce }\n\n  function find(callback) { return _find.call(this, callback).then(({ item }) => item) }\n  function findIndex(callback) { return _find.call(this, callback).then(({ index }) => index) }\n\n  function _find(iterable, callback) {\n    if (this.steps) return this.addStep('_find', [...arguments])\n    if (typeof iterable === 'function') {\n      callback = iterable\n      iterable = this._FP.promise\n    }\n\n    return FP.resolve(iterable)\n      .filter(callback)\n      .then((results) => results[0] != undefined ? { item: results[0], index: results.indexOf(results[0]) } : { item: undefined, index: -1 })\n  }\n  \n  function flatMap(iterable, callback) {\n    if (this.steps) return this.addStep('flatMap', [...arguments])\n    if (typeof iterable === 'function') {\n      callback = iterable\n      iterable = this._FP.promise\n    }\n    \n    return FP.resolve(iterable)\n      .map(callback)\n      .reduce((acc, arr) => acc.concat(...arr), [])\n  }\n\n\n  function filter(iterable, callback) {\n    if (this.steps) return this.addStep('filter', [...arguments])\n    if (typeof iterable === 'function') {\n      callback = iterable\n      iterable = this._FP.promise\n    }\n\n    return reduce.call(this, iterable, (acc, item) => Promise.resolve(callback(item)).then(x => (x ? acc.concat([item]) : acc)), [])\n  }\n\n  function reduce(iterable, reducer, initVal) {\n    if (this.steps) return this.addStep('reduce', [...arguments])\n    if (typeof iterable === 'function') {\n      initVal = reducer\n      reducer = iterable\n      iterable = this._FP ? this._FP.promise : this\n    } else iterable = FP.resolve(iterable, this)\n\n    return new FP((resolve, reject) => {\n      return iterable.then(iterable => {\n        const iterator = iterable[Symbol.iterator]()\n        let i = 0\n\n        const next = total => {\n          const current = iterator.next()\n          if (current.done) return resolve(total)\n\n          Promise.all([total, current.value])\n            .then(([total, item]) => next(reducer(total, item, i++))).catch(reject)\n        }\n\n        next(initVal)\n      })\n    })\n  }\n  \n  /*eslint max-statements: [\"error\", 60]*/\n  function map(args, fn, options) {\n    if (this.steps) return this.addStep('map', [...arguments])\n    if (arguments.length === 1 && this && this._FP) {\n      fn = args\n      args = this && this._FP && this._FP.promise\n    }\n    let resolvedOrRejected = false\n    const threadLimit = Math.max(1, (this && this._FP && this._FP.concurrencyLimit || 1))\n    const innerValues = this && this._FP && this._FP.promise ? this._FP.promise : Promise.resolve(args)\n    let initialThread = 0\n    let errors = []\n    let count = 0\n    const results = []\n    const threadPool = new Set()\n    const threadPoolFull = () => threadPool.size >= threadLimit\n    const isDone = () => errors.length > this._FP.errors.limit || count >= args.length || resolvedOrRejected\n    const setResult = index => value => {\n      threadPool.delete(index)\n      results[index] = value\n      return value\n    }\n    return FP.resolve(new Promise((resolve, reject) => {\n      const resolveIt = x => {\n        // console.log('Action.resolve:', resolvedOrRejected, x)\n        if (resolvedOrRejected) { return null } else { resolvedOrRejected = true }\n        resolve(x)\n      }\n      const rejectIt = x => {\n        if (resolvedOrRejected) { return null } else { resolvedOrRejected = true }\n        // console.log('Action.reject:', resolvedOrRejected, x)\n        reject(x)\n      }\n      innerValues.then(items => {\n        if (!isEnumerable(items)) return reject(new FPInputError(`Value must be iterable! A '${typeof items}' was passed into FP.map()`, {input: items}))\n        args = [...items]\n        const complete = () => {\n          let action = null\n          if (errors.length > this._FP.errors.limit) action = rejectIt\n          if (isDone()) action = resolveIt\n          if (action) return Promise.all(results).then(data => action(results)) ? true : true\n          return false\n        }\n        const checkAndRun = val => {\n          // console.log('checkAndRun', count, resolvedOrRejected, val)\n          if (resolvedOrRejected) return\n          if (!complete() && !results[count]) runItem(count)\n          return val\n        }\n\n        const runItem = c => {\n          if (resolvedOrRejected) {return null} else {count++}\n          if (threadPoolFull()) return setTimeout(() => runItem(c), 0)\n          if (results[c]) return results[c]\n          threadPool.add(c)\n          // either get value with `fn(item)` or `item.then(fn)`\n          results[c] = Promise.resolve(args[c])\n            .then(val => fn(val, c, args))\n            .then(val => setResult(c)(val))\n            .then(checkAndRun)\n            .catch(err => {\n              this._FP.errors.count++\n              err._index = c\n              errors.push(err)\n              if (this._FP.errors.limit <= 0) {\n                rejectIt(err)\n                return err\n              }\n              if (errors.length > this._FP.errors.limit) {\n                let fpErr = new FPCollectionError(`Error limit ${this._FP.errors.limit} met/exceeded with ${this._FP.errors.count} errors.`, { errors, results, ctx: this })\n                Promise.resolve(setResult(c)(err)).then(() => rejectIt(fpErr))\n              } else { // console.warn('Error OK:', JSON.stringify(this._FP.errors))\n                return Promise.resolve().then(() => setResult(c)(err)).then(checkAndRun)\n              }\n            })\n\n          return results[c]\n        }\n\n        // Kick off x number of initial threads\n        while (initialThread < threadLimit && initialThread < args.length) runItem(initialThread++)\n      })\n    }))\n  }\n}\n","import { FPInputError } from './modules/errors'\n\nexport const listen = function listen(obj, ...eventNames) {\n  if (typeof eventNames === 'string') eventNames = [eventNames]\n  if (!obj[obj.addEventListener ? 'addEventListener' : 'on']) throw new FPInputError('Valid EventEmitter required.')\n  // Gets callback to attach to the event handlers\n  const handler = this.chainEnd()\n  this._FP.destroy = () => this._FP.destroyHandles.map(fn => fn() || true).filter(v => v).length\n  this._FP.destroyHandles = eventNames.map(eventName => {\n    obj[obj.addEventListener ? 'addEventListener' : 'on'](eventName, handler)\n    return () => obj[obj.removeEventListener ? 'removeEventListener' : 'off'](eventName, handler)\n  })\n  return this\n}","import utils from './modules/utils'\n\nconst { isPromiseLike } = utils\n\nexport default function conditional(FP) {\n  return { tapIf, thenIf, _thenIf }\n\n  function thenIf(cond, ifTrue, ifFalse) {\n    if (this.steps) return this.addStep('thenIf', [...arguments])\n    if (arguments.length === 1) {\n      ifTrue = cond\n      cond = x => x\n    }\n    if (isPromiseLike(this)) {\n      return this.then(value => _thenIf(cond, ifTrue, ifFalse)(value))\n    }\n    return _thenIf(cond, ifTrue, ifFalse)\n  }\n\n  function tapIf(cond, ifTrue, ifFalse) {\n    if (this.steps) return this.addStep('tapIf', [...arguments])\n    if (arguments.length === 1) {\n      ifTrue = cond\n      cond = x => x\n    }\n    if (isPromiseLike(this)) {\n      return this.then(value => _thenIf(cond, ifTrue, ifFalse, true)(value))\n    }\n    return _thenIf(cond, ifTrue, ifFalse, true)\n  }\n\n  function _thenIf(cond = x => x, ifTrue = x => x, ifFalse = () => null, returnValue = false) {\n    return value =>\n      FP.resolve(cond(value))\n        .then(ans => (ans ? ifTrue(value) : ifFalse(value)))\n        .then(v => (returnValue ? value : v))\n  }\n}\n","import { FPInputError } from './modules/errors.js'\n\n/**\n * \n * @param {FP} FunctionalPromises \n */\nexport default function promise(FP) {\n\n  return { all, delay, _delay }\n\n  function all(promises) {\n    return FP.resolve(Array.isArray(promises) ? Promise.all(promises) : promiseAllObject(promises))\n  }\n\n  function promiseAllObject(obj) {\n    const keys = Object.getOwnPropertyNames(obj)\n    const values = keys.map(key => obj[key])\n    return Promise.all(values).then(results => results.reduce((obj, val, index) => {\n      const key = keys[index]\n      return Object.assign({ [key]: val }, obj)\n    }, {}))\n  }\n\n  /**\n   * \n   * @param {Number} msec \n   * @returns {any => FP}\n   */\n  function _delay(msec) {\n    if (!Number.isInteger(msec)) throw new FPInputError('FP.delay(millisec) requires a numeric arg.')\n    return value => new FP(resolve => { setTimeout(() => resolve(value), msec) })\n  }\n\n  function delay(msec) {\n    if (this.steps) return this.addStep('delay', [...arguments])\n    return this && this._FP ? FP.resolve(this.then(_delay(msec))) : _delay(msec)()\n  }\n}\n","/// <reference path=\"../index.d.ts\" />\n// <amd-module name=\"FP\"/>\n\nimport { FunctionalError } from './modules/errors'\nimport utils from './modules/utils'\nimport monads from './monads'\nimport arrays from './arrays'\nimport { listen } from './events'\nimport conditional from './conditional'\nimport promise from './promise'\n\n\nconst { isFunction, flatten } = utils\nconst { map, find, findIndex, filter, flatMap, reduce } = arrays(FP)\nconst { all, delay, _delay } = promise(FP)\nconst { tapIf, thenIf, _thenIf } = conditional(FP)\nconst { chain, chainEnd } = monads(FP)\n\nFP.prototype.all = all\nFP.prototype.map = map\nFP.prototype.find = find\nFP.prototype.findIndex = findIndex\nFP.prototype.filter = filter\nFP.prototype.flatMap = flatMap\nFP.prototype.reduce = reduce\nFP.prototype.listen = listen\nFP.prototype.tapIf = tapIf\nFP.prototype.thenIf = thenIf\nFP.prototype._thenIf = _thenIf\nFP.prototype.delay = delay\nFP.prototype._delay = _delay\nFP.prototype.reject = reject\n\n// FP.default = FP\n// export const all = allPromises\n\nFP.all = FP.prototype.all\nFP.thenIf = FP.prototype._thenIf\nFP.delay = msec => FP.resolve().delay(msec)\nFP.silent = limit => FP.resolve().silent(limit)\n\n// Monadic Methods\nFP.chain = chain\nFP.prototype.chainEnd = chainEnd\nFP.reject = FP.prototype.reject\nFP.resolve = resolve\n\nFP.promisify = promisify\nFP.promisifyAll = promisifyAll\nFP.unpack = unpack\n\nFP.prototype.addStep = function addStep(name, args) {\n  if (this.steps) this.steps.push([name, this, args])\n  return this\n}\n\nFP.prototype.concurrency = function concurrency(limit = Infinity) {\n  if (this.steps) return this.addStep('concurrency', [...arguments])\n  this._FP.concurrencyLimit = limit\n  return this\n}\n\nFP.prototype.quiet = function quiet(errorLimit = Infinity) {\n  if (this.steps) return this.addStep('quiet', [...arguments])\n  this._FP.errors = { count: 0, limit: errorLimit }\n  return this\n}\nFP.prototype.silent = FP.prototype.quiet\n\n/**\n * Helper to accumulate string keys *until an object is provided*. \n * Returns a partial function to accept more keys until partial \n */\nFP.get = function getter(...getArgs) {\n  getArgs = flatten(getArgs)\n  const keyNames = getArgs.filter(s => typeof s === 'string')\n  const objectFound = getArgs.find(s => typeof s !== 'string')\n  // Return partial app / auto-curry deal here\n  if (!objectFound) { // return function to keep going\n    return (...extraArgs) => FP.get(...extraArgs, ...getArgs)\n  }\n\n  if (keyNames.length === 1) return objectFound[keyNames[0]]\n  return keyNames.reduce((extracted, key) => {\n    extracted[key] = objectFound[key]\n    return extracted\n  }, {})\n\n}\n\nFP.prototype.get = function get(...keyNames) {\n  if (this.steps) return this.addStep('get', [...arguments])\n  return this.then\n     ? this.then(FP.get(keyNames))\n     : FP.get(...keyNames)\n}\n\nFP.prototype.set = function set(keyName, value) {\n  if (this.steps) return this.addStep('set', [...arguments])\n  return this.then(obj => {\n    if (typeof obj === 'object') obj[keyName] = value\n    return obj\n  })\n}\n\nFP.prototype.catch = function (fn) {\n  if (this.steps) return this.addStep('catch', [...arguments])\n  if (arguments.length === 2) return this.catchIf(...arguments)\n  if (!isFunction(fn)) throw new FunctionalError('Invalid fn argument for `.catch(fn)`. Must be a function. Currently: ' + typeof fn)\n  return FP.resolve(this._FP.promise.catch(err => fn(err)))\n}\n\nFP.prototype.catchIf = function catchIf(condition, fn) {\n  if (this.steps) return this.addStep('catchIf', [...arguments])\n  if (!isFunction(fn)) throw new FunctionalError('Invalid fn argument for `.catchIf(condition, fn)`. Must be a function. Currently: ' + typeof fn)\n\n  return FP.resolve(this._FP.promise.catch(err => {\n    if (condition && err instanceof condition) return fn(err) // try re-throw, might be really slow...\n    throw err\n  }))\n}\n\nFP.prototype.then = function then(onFulfilled, onRejected) {\n  if (this.steps) return this.addStep('then', [...arguments])\n  if (!isFunction(onFulfilled)) throw new FunctionalError('Invalid fn argument for `.then(fn)`. Must be a function. Currently: ' + typeof onResolved)\n  return FP.resolve(this._FP.promise.then(onFulfilled, onRejected))\n}\n\nFP.prototype.tap = function tap(fn) {\n  if (this.steps) return this.addStep('tap', [...arguments])\n  if (!isFunction(fn)) throw new FunctionalError('Invalid fn argument for `.tap(fn)`. Must be a function. Currently: ' + typeof fn)\n  return FP.resolve(this._FP.promise.then(value => fn(value) ? value : value))\n}\n\nfunction resolve(value) {\n  return new FP((resolve, reject) => {\n    if (value && isFunction(value.then)) return value.then(resolve).catch(reject)\n    resolve(value)\n  })\n}\n\nfunction promisify(cb) {\n  return (...args) => new FP((yah, nah) =>\n    cb.call(this, ...args, (err, res) => err ? nah(err) : yah(res)))\n}\n\nfunction promisifyAll(obj) {\n  if (!obj || !Object.getPrototypeOf(obj)) { throw new Error('Invalid Argument obj in promisifyAll(obj)') }\n  return Object.getOwnPropertyNames(obj)\n    .filter(key => typeof obj[key] === 'function')\n    .reduce((obj, fnName) => {\n      if (!/Sync/.test(fnName) && !obj[`${fnName}Async`]) obj[`${fnName}Async`] = FP.promisify(obj[`${fnName}`])\n      return obj\n    }, obj)\n}\n\nfunction unpack() {\n  let resolve, reject, promise = new FP((yah, nah) => { resolve = yah; reject = nah })\n  return { promise, resolve, reject }\n}\n\n/**\n * @param {Error} err \n * @returns {Promise<Error>}\n */\nfunction reject(err) {\n  if (err instanceof Error) {\n    if (this) this._error = err\n    return Promise.reject(err)\n  }\n  throw new Error(`Reject only accepts a new instance of Error!`)\n}\n\nexport default function FP(resolveRejectCB) {\n  if (!(this instanceof FP)) { return new FP(resolveRejectCB) }\n  if (arguments.length !== 1) throw new Error('FunctionalPromises constructor only accepts 1 callback argument')\n  this._FP = {\n    errors:           { limit: 0, count: 0 },\n    promise:          new Promise(resolveRejectCB),\n    concurrencyLimit: 4,\n  }\n}\n// if (process && process.on) {\n//   // process.on('uncaughtException', e => console.error('FPromises: FATAL EXCEPTION: uncaughtException', e))\n//   process.on('unhandledRejection', e => console.error('FPromises: FATAL ERROR: unhandledRejection', e))\n// }\n"],"names":["require","inherits","FunctionalError","msg","options","this","arguments","message","Error","call","Object","getOwnPropertyNames","forEach","key","_this","name","constructor","captureStackTrace","FunctionalUserError","FPUnexpectedError","FPInputError","FPCollectionError","FPTimeout","utils","isPromiseLike","p","then","isFunction","fn","isEnumerable","list","Array","isArray","Symbol","iterator","isObject","o","prototype","toString","flatten","arr","reduce","results","item","concat","monads","FP","chain","promise","resolve","steps","chainEnd","input","length","stepCount","unpack","reject","fnName","args","map","addStep","_FP","setResult","index","value","threadPool","resolvedOrRejected","threadLimit","Math","max","concurrencyLimit","innerValues","Promise","initialThread","errors","count","Set","resolveIt","x","rejectIt","items","complete","action","limit","all","data","checkAndRun","val","runItem","c","size","setTimeout","add","err","_index","push","fpErr","ctx","find","callback","_find","findIndex","filter","iterable","acc","flatMap","undefined","indexOf","reducer","initVal","i","next","total","current","done","listen","obj","eventNames","addEventListener","handler","destroy","destroyHandles","v","eventName","removeEventListener","conditional","tapIf","cond","ifTrue","ifFalse","_thenIf","thenIf","returnValue","ans","promises","keys","values","assign","promiseAllObject","delay","msec","_delay","Number","isInteger","arrays","promisify","cb","yah","nah","res","promisifyAll","getPrototypeOf","test","_error","resolveRejectCB","silent","concurrency","Infinity","quiet","errorLimit","get","getArgs","keyNames","s","objectFound","extracted","extraArgs","set","keyName","catchIf","condition","onFulfilled","onRejected","onResolved","tap"],"mappings":"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"}