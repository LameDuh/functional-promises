{"version":3,"file":"cjs.min.js","sources":["../src/modules/errors.js","../src/modules/utils.js","../src/monads.js","../src/arrays.js","../src/events.js","../src/conditional.js","../src/promise.js","../src/index.js"],"sourcesContent":["const { inherits } = require('util');\n\ninherits(FunctionalError, Error)\n\ninherits(FunctionalUserError, FunctionalError)\ninherits(FPCollectionError, FunctionalError)\ninherits(FPUnexpectedError, FunctionalError)\ninherits(FPInputError, FunctionalError)\ninherits(FPTimeout, FunctionalError)\n\nexport function FunctionalError(msg, options) {\n  if (!(this instanceof FunctionalError)) return new FunctionalError(...arguments)\n  if (typeof msg === 'object') {\n    options = msg\n    if ( options.message ) msg = options.message\n  }\n  Error.call(this, msg)\n  if (typeof msg === 'string') this.message = msg\n  if (typeof options === 'object') {\n    Object.getOwnPropertyNames(options)\n      .forEach(key => {\n        this[key] = options[key]\n      })\n  }\n  this.name = this.constructor.name\n  // Capturing stack trace, excluding constructor call from it.\n  Error.captureStackTrace(this)\n}\n\nexport function FunctionalUserError() {\n  if (!(this instanceof FunctionalUserError)) return new FunctionalUserError(...arguments)\n  FunctionalError.call(this, ...arguments)\n}\n\nexport function FPUnexpectedError() {\n  if (!(this instanceof FPUnexpectedError)) return new FPUnexpectedError(...arguments)\n  FunctionalError.call(this, ...arguments)\n}\n\nexport function FPInputError() {\n  if (!(this instanceof FPInputError)) return new FPInputError(...arguments)\n  FunctionalError.call(this, ...arguments)\n}\n\nexport function FPCollectionError() {\n  if (!(this instanceof FPCollectionError)) return new FPCollectionError(...arguments)\n  FunctionalError.call(this, ...arguments)\n}\n\nexport function FPTimeout() {\n  if (!(this instanceof FPTimeout)) return new FPTimeout(...arguments)\n  FunctionalError.call(this, ...arguments)\n}\n\n\n","const utils = {\n  isPromiseLike(p) { return !!(p && typeof p.then === 'function') },\n  isFunction(fn) { return typeof fn === 'function' },\n  isEnumerable(list) { return list && Array.isArray(list) || list && typeof list[Symbol.iterator] === 'function' },\n  isObject(o) { return !!Object.prototype.toString.call(o) === '[object Object]' },\n\n  flatten(arr) {\n    if (!Array.isArray(arr)) throw new Error('Method `flatten` requires valid array parameter')\n    return arr.reduce((results, item) => results.concat(Array.isArray(item) ? utils.flatten(item) : [item]), [])\n  },\n}\nexport default utils","import { FPInputError } from './modules/errors'\n\nexport default function monads(FP) {\n\n  return {chain, chainEnd}\n\n  /**\n   * Start 'recording' a chain of commands, after steps defined call `.chainEnd()`\n   * @returns FunctionalPromise\n   */\n  function chain() {\n    // create a placeholder/initial promise to hold the steps/chain data\n    const promise = FP.resolve()\n    promise.steps = []\n    return promise\n  }\n\n  /**\n   * Call after starting a `.chain()`.\n   *\n   * One of the few non-chainable methods in the API.\n   * @returns a Function. It runs your functional chain!\n   */\n  function chainEnd() {\n    return input => {\n      if (!this.steps || this.steps.length <= 0) throw new FPInputError('No steps defined between .chain() & .chainEnd()')\n      let stepCount = 0\n      let {promise, resolve, reject} = FP.unpack()\n      while (stepCount < this.steps.length) {\n        const [fnName, , args] = this.steps[stepCount]\n        promise = promise[fnName](...args)\n        stepCount++\n      }\n      resolve(input)\n      return promise\n    }\n  }\n}\n","import utils from './modules/utils'\nimport { FPInputError, FPCollectionError, FunctionalError } from './modules/errors'\nconst { isEnumerable } = utils\n\nexport default function(FP) {\n\n  return { map, find, findIndex, filter, flatMap, reduce }\n\n  function find(callback) { return _find.call(this, callback).then(({ item }) => item) }\n  function findIndex(callback) { return _find.call(this, callback).then(({ index }) => index) }\n\n  function _find(iterable, callback) {\n    if (this.steps) return this.addStep('_find', [...arguments])\n    if (typeof iterable === 'function') {\n      callback = iterable\n      iterable = this._FP.promise\n    }\n\n    return FP.resolve(iterable)\n      .filter(callback)\n      .then((results) => results[0] != undefined ? { item: results[0], index: results.indexOf(results[0]) } : { item: undefined, index: -1 })\n  }\n  \n  function flatMap(iterable, callback) {\n    if (this.steps) return this.addStep('flatMap', [...arguments])\n    if (typeof iterable === 'function') {\n      callback = iterable\n      iterable = this._FP.promise\n    }\n    \n    return FP.resolve(iterable)\n      .map(callback)\n      .reduce((acc, arr) => acc.concat(...arr), [])\n  }\n\n\n  function filter(iterable, callback) {\n    if (this.steps) return this.addStep('filter', [...arguments])\n    if (typeof iterable === 'function') {\n      callback = iterable\n      iterable = this._FP.promise\n    }\n\n    return reduce.call(this, iterable, (acc, item) => Promise.resolve(callback(item)).then(x => (x ? acc.concat([item]) : acc)), [])\n  }\n\n  function reduce(iterable, reducer, initVal) {\n    if (this.steps) return this.addStep('reduce', [...arguments])\n    if (typeof iterable === 'function') {\n      initVal = reducer\n      reducer = iterable\n      iterable = this._FP ? this._FP.promise : this\n    } else iterable = FP.resolve(iterable, this)\n\n    return new FP((resolve, reject) => {\n      return iterable.then(iterable => {\n        const iterator = iterable[Symbol.iterator]()\n        let i = 0\n\n        const next = total => {\n          const current = iterator.next()\n          if (current.done) return resolve(total)\n\n          Promise.all([total, current.value])\n            .then(([total, item]) => next(reducer(total, item, i++))).catch(reject)\n        }\n\n        next(initVal)\n      })\n    })\n  }\n  \n  /*eslint max-statements: [\"error\", 60]*/\n  function map(args, fn, options) {\n    if (this.steps) return this.addStep('map', [...arguments])\n    if (arguments.length === 1 && this && this._FP) {\n      fn = args\n      args = this && this._FP && this._FP.promise\n    }\n    let resolvedOrRejected = false\n    const threadLimit = Math.max(1, (this && this._FP && this._FP.concurrencyLimit || 1))\n    const innerValues = this && this._FP && this._FP.promise ? this._FP.promise : Promise.resolve(args)\n    let initialThread = 0\n    let errors = []\n    let count = 0\n    const results = []\n    const threadPool = new Set()\n    const threadPoolFull = () => threadPool.size >= threadLimit\n    const isDone = () => errors.length > this._FP.errors.limit || count >= args.length || resolvedOrRejected\n    const setResult = index => value => {\n      threadPool.delete(index)\n      results[index] = value\n      return value\n    }\n    return FP.resolve(new Promise((resolve, reject) => {\n      const resolveIt = x => {\n        // console.log('Action.resolve:', resolvedOrRejected, x)\n        if (resolvedOrRejected) { return null } else { resolvedOrRejected = true }\n        resolve(x)\n      }\n      const rejectIt = x => {\n        if (resolvedOrRejected) { return null } else { resolvedOrRejected = true }\n        // console.log('Action.reject:', resolvedOrRejected, x)\n        reject(x)\n      }\n      innerValues.then(items => {\n        if (!isEnumerable(items)) return reject(new FPCollectionError(`Value must be iterable! A '${typeof items}' was passed into FP.map()`))\n        args = [...items]\n        const complete = () => {\n          let action = null\n          if (errors.length > this._FP.errors.limit) action = rejectIt\n          if (isDone()) action = resolveIt\n          if (action) return Promise.all(results).then(data => action(results)) ? true : true\n          return false\n        }\n        const checkAndRun = val => {\n          // console.log('checkAndRun', count, resolvedOrRejected, val)\n          if (resolvedOrRejected) return\n          if (!complete() && !results[count]) runItem(count)\n          return val\n        }\n\n        const runItem = c => {\n          if (resolvedOrRejected) {return null} else {count++}\n          if (threadPoolFull()) return setTimeout(() => runItem(c), 0)\n          if (results[c]) return results[c]\n          threadPool.add(c)\n          // either get value with `fn(item)` or `item.then(fn)`\n          results[c] = Promise.resolve(args[c])\n            .then(val => fn(val, c, args))\n            .then(val => setResult(c)(val))\n            .then(checkAndRun)\n            .catch(err => {\n              this._FP.errors.count++\n              errors.push(err)\n              if (this._FP.errors.limit <= 0) {\n                rejectIt(err)\n                return err\n              }\n              if (errors.length > this._FP.errors.limit) {\n                let fpErr = errors.length >= 1 ? new FPCollectionError(`Error Limit ${this._FP.errors.limit} Exceeded.\n                idx=${c} errCnt=${this._FP.errors.count}`, { errors, results, ctx: this }) : err\n                Promise.resolve(setResult(c)(err)).then(() => rejectIt(fpErr))\n              } else { // console.warn('Error OK:', JSON.stringify(this._FP.errors))\n                return Promise.resolve().then(() => setResult(c)(err)).then(checkAndRun)\n              }\n            })\n\n          return results[c]\n        }\n\n        // Kick off x number of initial threads\n        while (initialThread < threadLimit && initialThread < args.length) runItem(initialThread++)\n      })\n    }))\n  }\n}\n","import { FPInputError } from './modules/errors'\n\nexport const listen = function listen(obj, ...eventNames) {\n  if (typeof eventNames === 'string') eventNames = [eventNames]\n  if (!obj[obj.addEventListener ? 'addEventListener' : 'on']) throw new FPInputError('Valid EventEmitter required.')\n  // Gets callback to attach to the event handlers\n  const handler = this.chainEnd()\n  this._FP.destroy = () => this._FP.destroyHandles.map(fn => fn() || true).filter(v => v).length\n  this._FP.destroyHandles = eventNames.map(eventName => {\n    obj[obj.addEventListener ? 'addEventListener' : 'on'](eventName, handler)\n    return () => obj[obj.removeEventListener ? 'removeEventListener' : 'off'](eventName, handler)\n  })\n  return this\n}","import utils from './modules/utils'\n\nconst { isPromiseLike } = utils\n\nexport default function conditional(FP) {\n  return { tapIf, thenIf, _thenIf }\n\n  function thenIf(cond, ifTrue, ifFalse) {\n    if (this.steps) return this.addStep('thenIf', [...arguments])\n    if (arguments.length === 1) {\n      ifTrue = cond\n      cond = x => x\n    }\n    if (isPromiseLike(this)) {\n      return this.then(value => _thenIf(cond, ifTrue, ifFalse)(value))\n    }\n    return _thenIf(cond, ifTrue, ifFalse)\n  }\n\n  function tapIf(cond, ifTrue, ifFalse) {\n    if (this.steps) return this.addStep('tapIf', [...arguments])\n    if (arguments.length === 1) {\n      ifTrue = cond\n      cond = x => x\n    }\n    if (isPromiseLike(this)) {\n      return this.then(value => _thenIf(cond, ifTrue, ifFalse, true)(value))\n    }\n    return _thenIf(cond, ifTrue, ifFalse, true)\n  }\n\n  function _thenIf(cond = x => x, ifTrue = x => x, ifFalse = () => null, returnValue = false) {\n    return value =>\n      FP.resolve(cond(value))\n        .then(ans => (ans ? ifTrue(value) : ifFalse(value)))\n        .then(v => (returnValue ? value : v))\n  }\n}\n","import { FPInputError } from './modules/errors'\n\nexport default function(FP) {\n\n  return { all, reject, delay, _delay }\n\n  function all(promises) {\n    return FP.resolve(Array.isArray(promises) ? Promise.all(promises) : promiseAllObject(promises))\n  }\n\n  function promiseAllObject(obj) {\n    const keys = Object.getOwnPropertyNames(obj)\n    const values = keys.map(key => obj[key])\n    return Promise.all(values).then(results => results.reduce((obj, val, index) => {\n      const key = keys[index]\n      return Object.assign({ [key]: val }, obj)\n    }, {}))\n  }\n\n  function reject(err) {\n    if (err instanceof Error) {\n      if (this) this._error = err\n      return Promise.reject(err)\n    }\n    throw new Error(`Reject only accepts a new instance of Error!`)\n  }\n\n  function _delay(msec) {\n    if (!Number.isInteger(msec)) throw new FPInputError('FP.delay(millisec) requires a numeric arg.')\n    return value => new FP(resolve => { setTimeout(() => resolve(value), msec) })\n  }\n\n  function delay(msec) {\n    if (this.steps) return this.addStep('delay', [...arguments])\n    return this && this._FP ? FP.resolve(this.then(_delay(msec))) : _delay(msec)()\n  }\n}\n","import { FunctionalError } from './modules/errors'\nimport utils from './modules/utils'\nimport monads from './monads'\nimport arrays from './arrays'\nimport { listen } from './events'\nimport conditional from './conditional'\nimport promise from './promise'\n\n\nconst { isFunction, flatten } = utils\nconst { map, find, findIndex, filter, flatMap, reduce } = arrays(FP)\nconst { all, reject, delay, _delay } = promise(FP)\nconst { tapIf, thenIf, _thenIf } = conditional(FP)\nconst { chain, chainEnd } = monads(FP)\n\nFP.prototype.all = all\nFP.prototype.map = map\nFP.prototype.find = find\nFP.prototype.findIndex = findIndex\nFP.prototype.filter = filter\nFP.prototype.flatMap = flatMap\nFP.prototype.reduce = reduce\nFP.prototype.listen = listen\nFP.prototype.tapIf = tapIf\nFP.prototype.thenIf = thenIf\nFP.prototype._thenIf = _thenIf\nFP.prototype.delay = delay\nFP.prototype._delay = _delay\nFP.prototype.reject = reject\n\n// FP.default = FP\n// export const all = allPromises\n\nFP.all = FP.prototype.all\nFP.thenIf = FP.prototype._thenIf\nFP.delay = msec => FP.resolve().delay(msec)\nFP.silent = limit => FP.resolve().silent(limit)\n\n// Monadic Methods\nFP.chain = chain\nFP.prototype.chainEnd = chainEnd\nFP.reject = FP.prototype.reject\nFP.resolve = resolve\n\nFP.promisify = promisify\nFP.promisifyAll = promisifyAll\nFP.unpack = unpack\n\nFP.prototype.addStep = function addStep(name, args) {\n  if (this.steps) this.steps.push([name, this, args])\n  return this\n}\n\nFP.prototype.concurrency = function concurrency(limit = Infinity) {\n  if (this.steps) return this.addStep('concurrency', [...arguments])\n  this._FP.concurrencyLimit = limit\n  return this\n}\n\nFP.prototype.quiet = function quiet(errorLimit = Infinity) {\n  if (this.steps) return this.addStep('quiet', [...arguments])\n  this._FP.errors = { count: 0, limit: errorLimit }\n  return this\n}\nFP.prototype.silent = FP.prototype.quiet\n\n/**\n * Helper to accumulate string keys *until an object is provided*. \n * Returns a partial function to accept more keys until partial \n */\nFP.get = function getter(...getArgs) {\n  getArgs = flatten(getArgs)\n  const keyNames = getArgs.filter(s => typeof s === 'string')\n  const objectFound = getArgs.find(s => typeof s !== 'string')\n  // Return partial app / auto-curry deal here\n  if (!objectFound) { // return function to keep going\n    return (...extraArgs) => FP.get(...extraArgs, ...getArgs)\n  }\n\n  if (keyNames.length === 1) return objectFound[keyNames[0]]\n  return keyNames.reduce((extracted, key) => {\n    extracted[key] = objectFound[key]\n    return extracted\n  }, {})\n\n}\n\nFP.prototype.get = function get(...keyNames) {\n  if (this.steps) return this.addStep('get', [...arguments])\n  return this.then\n     ? this.then(FP.get(keyNames))\n     : FP.get(...keyNames)\n}\n\nFP.prototype.set = function set(keyName, value) {\n  if (this.steps) return this.addStep('set', [...arguments])\n  return this.then(obj => {\n    if (typeof obj === 'object') obj[keyName] = value\n    return obj\n  })\n}\n\nFP.prototype.catch = function (fn) {\n  if (this.steps) return this.addStep('catch', [...arguments])\n  if (arguments.length === 2) return this.catchIf(...arguments)\n  if (!isFunction(fn)) throw new FunctionalError('Invalid fn argument for `.catch(fn)`. Must be a function. Currently: ' + typeof fn)\n  return FP.resolve(this._FP.promise.catch(err => fn(err)))\n}\n\nFP.prototype.catchIf = function catchIf(condition, fn) {\n  if (this.steps) return this.addStep('catchIf', [...arguments])\n  if (!isFunction(fn)) throw new FunctionalError('Invalid fn argument for `.catchIf(condition, fn)`. Must be a function. Currently: ' + typeof fn)\n\n  return FP.resolve(this._FP.promise.catch(err => {\n    if (condition && err instanceof condition) return fn(err) // try re-throw, might be really slow...\n    throw err\n  }))\n}\n\nFP.prototype.then = function then(fn) {\n  if (this.steps) return this.addStep('then', [...arguments])\n  if (!isFunction(fn)) throw new FunctionalError('Invalid fn argument for `.then(fn)`. Must be a function. Currently: ' + typeof fn)\n  return FP.resolve(this._FP.promise.then(fn))\n}\n\nFP.prototype.tap = function tap(fn) {\n  if (this.steps) return this.addStep('tap', [...arguments])\n  if (!isFunction(fn)) throw new FunctionalError('Invalid fn argument for `.tap(fn)`. Must be a function. Currently: ' + typeof fn)\n  return FP.resolve(this._FP.promise.then(value => fn(value) ? value : value))\n}\n\nfunction resolve(value) {\n  return new FP((resolve, reject) => {\n    if (value && isFunction(value.then)) return value.then(resolve).catch(reject)\n    resolve(value)\n  })\n}\n\nfunction promisify(cb) {\n  return (...args) => new FP((yah, nah) =>\n    cb.call(this, ...args, (err, res) => err ? nah(err) : yah(res)))\n}\n\nfunction promisifyAll(obj) {\n  if (!obj || !Object.getPrototypeOf(obj)) { throw new Error('Invalid Argument obj in promisifyAll(obj)') }\n  return Object.getOwnPropertyNames(obj)\n    .filter(key => typeof obj[key] === 'function')\n    .reduce((obj, fnName) => {\n      if (!/Sync/.test(fnName) && !obj[`${fnName}Async`]) obj[`${fnName}Async`] = FP.promisify(obj[`${fnName}`])\n      return obj\n    }, obj)\n}\n\nfunction unpack() {\n  let resolve, reject, promise = new FP((yah, nah) => { resolve = yah; reject = nah })\n  return { promise, resolve, reject }\n}\n\n\nexport default function FP(resolveRejectCB) {\n  if (!(this instanceof FP)) { return new FP(resolveRejectCB) }\n  if (arguments.length !== 1) throw new Error('FunctionalPromises constructor only accepts 1 callback argument')\n  this._FP = {\n    errors:           { limit: 0, count: 0 },\n    promise:          new Promise(resolveRejectCB),\n    concurrencyLimit: 4,\n  }\n}\n// if (process && process.on) {\n//   // process.on('uncaughtException', e => console.error('FPromises: FATAL EXCEPTION: uncaughtException', e))\n//   process.on('unhandledRejection', e => console.error('FPromises: FATAL ERROR: unhandledRejection', e))\n// }\n"],"names":["require","inherits","FunctionalError","msg","options","this","arguments","message","Error","call","Object","getOwnPropertyNames","forEach","key","_this","name","constructor","captureStackTrace","FunctionalUserError","FPUnexpectedError","FPInputError","FPCollectionError","FPTimeout","utils","isPromiseLike","p","then","isFunction","fn","isEnumerable","list","Array","isArray","Symbol","iterator","isObject","o","prototype","toString","flatten","arr","reduce","results","item","concat","monads","FP","chain","promise","resolve","steps","chainEnd","input","length","stepCount","unpack","reject","fnName","args","map","addStep","_FP","resolvedOrRejected","threadLimit","Math","max","concurrencyLimit","innerValues","Promise","initialThread","errors","count","threadPool","Set","setResult","index","value","resolveIt","x","rejectIt","items","complete","action","limit","isDone","all","data","checkAndRun","val","runItem","c","size","threadPoolFull","setTimeout","add","err","push","fpErr","ctx","find","callback","_find","findIndex","filter","iterable","acc","flatMap","undefined","indexOf","reducer","initVal","i","next","total","current","done","listen","obj","eventNames","addEventListener","handler","destroy","destroyHandles","v","eventName","removeEventListener","conditional","tapIf","cond","ifTrue","ifFalse","_thenIf","thenIf","returnValue","ans","promises","keys","values","assign","promiseAllObject","_error","delay","msec","_delay","Number","isInteger","arrays","promisify","cb","yah","nah","res","promisifyAll","getPrototypeOf","test","resolveRejectCB","silent","concurrency","Infinity","quiet","errorLimit","get","getArgs","keyNames","s","objectFound","extracted","extraArgs","set","keyName","catchIf","condition","tap"],"mappings":"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"}